//
// Created by konek on 7/26/2019.
//

#ifndef GLNE_GLIS_H
#define GLNE_GLIS_H

#include <android/native_window.h> // requires ndk r5 or newer
#include <EGL/egl.h> // requires ndk r5 or newer
#include <GLES3/gl32.h>
#include <cstdlib>
#include <cassert>
#include "logger.h"

#define LOG_TAG "EglSample"

#define GLIS_SWITCH_CASE_CUSTOM_CASE_CUSTOM_LOGGER_CUSTOM_STRING_CAN_I_PRINT_ERROR(LOGGING_FUNCTION, CASE_NAME, name, const, constSTRING, UNNAMED_STRING_CAN_PRINT_ERROR, UNNAMED_STRING_CANNOT_PRINT_ERROR, NAMED_STRING_CAN_PRINT_ERROR, NAMED_STRING_CANNOT_PRINT_ERROR, PRINT) CASE_NAME: { \
    if(name == nullptr || name == NULL || name == 0) { \
        if (PRINT) { \
            if (UNNAMED_STRING_CAN_PRINT_ERROR != nullptr) { \
                LOGGING_FUNCTION(UNNAMED_STRING_CAN_PRINT_ERROR, constSTRING); \
            } \
        } \
        else { \
            if (UNNAMED_STRING_CANNOT_PRINT_ERROR != nullptr) { \
                LOGGING_FUNCTION(UNNAMED_STRING_CANNOT_PRINT_ERROR); \
            } \
        } \
    } \
    else { \
        if (PRINT) { \
            if (NAMED_STRING_CAN_PRINT_ERROR != nullptr) { \
                LOGGING_FUNCTION(NAMED_STRING_CAN_PRINT_ERROR, name, constSTRING); \
            } \
        } \
        else { \
            if (NAMED_STRING_CANNOT_PRINT_ERROR != nullptr) { \
                LOGGING_FUNCTION(NAMED_STRING_CANNOT_PRINT_ERROR, name); \
            } \
        } \
    } \
    break; \
}


#define GLIS_SWITCH_CASE_CUSTOM_LOGGER_CUSTOM_STRING_DONT_PRINT_ERROR(LOGGER, name, const, constSTRING, UNNAMED_STRING, NAMED_STRING) \
    GLIS_SWITCH_CASE_CUSTOM_CASE_CUSTOM_LOGGER_CUSTOM_STRING_CAN_I_PRINT_ERROR(LOGGER, case const, name, const, constSTRING, nullptr, UNNAMED_STRING, nullptr, NAMED_STRING, false)
    
#define GLIS_SWITCH_CASE_CUSTOM_LOGGER_CUSTOM_STRING(LOGGER, name, const, constSTRING, UNNAMED_STRING, NAMED_STRING) \
    GLIS_SWITCH_CASE_CUSTOM_CASE_CUSTOM_LOGGER_CUSTOM_STRING_CAN_I_PRINT_ERROR(LOGGER, case const, name, const, constSTRING, UNNAMED_STRING, nullptr, NAMED_STRING, nullptr, true)

#define GLIS_ERROR_SWITCH_CASE_CUSTOM_STRING_DONT_PRINT_ERROR(name, const, constSTRING, UNNAMED_STRING, NAMED_STRING) \
    GLIS_SWITCH_CASE_CUSTOM_LOGGER_CUSTOM_STRING_DONT_PRINT_ERROR(LOG_ERROR, name, const, constSTRING, UNNAMED_STRING, NAMED_STRING)

#define GLIS_ERROR_SWITCH_CASE_CUSTOM_STRING(name, const, constSTRING, UNNAMED_STRING, NAMED_STRING) \
    GLIS_SWITCH_CASE_CUSTOM_LOGGER_CUSTOM_STRING(LOG_ERROR, name, const, constSTRING, UNNAMED_STRING, NAMED_STRING)

#define GLIS_ERROR_SWITCH_CASE(name, const) \
    GLIS_ERROR_SWITCH_CASE_CUSTOM_STRING(name, const, #const, "%s", "%s generated error: %s")

#define GLIS_ERROR_SWITCH_CASE_DEFAULT(name, err) \
    GLIS_SWITCH_CASE_CUSTOM_CASE_CUSTOM_LOGGER_CUSTOM_STRING_CAN_I_PRINT_ERROR(LOG_ERROR, default, name, err, err, "Unknown error: %d", "Unknown error", "%s generated an unknown error: %d", "%s generated an unknown error", true)

#define GLIS_boolean_to_string(val, TRUE_VALUE) val == TRUE_VALUE ? "true" : "false"

#define GLIS_SHADER_SOURCE__BEGIN R"glsl(
#define GLIS_SHADER_SOURCE__END )glsl";
#define GLIS_SHADER_SOURCE__(S, source, E) S source E
#define GLIS_SHADER_SOURCE(source) GLIS_SHADER_SOURCE__(GLIS_SHADER_SOURCE__BEGIN, source, GLIS_SHADER_SOURCE__END)

#define GLIS_error_to_string_exec(x) x; GLIS_error_to_string(#x)

void GLIS_error_to_string(const char * name, GLint err) {
    switch(err) {

        // GENERATED BY glGetError() ITSELF
        GLIS_SWITCH_CASE_CUSTOM_LOGGER_CUSTOM_STRING_DONT_PRINT_ERROR(LOG_INFO, name, GL_NO_ERROR, "GL_NO_ERROR", "no error was generated", "%s did not generate an error")
        GLIS_ERROR_SWITCH_CASE(name, GL_INVALID_ENUM)
        GLIS_ERROR_SWITCH_CASE(name, GL_INVALID_VALUE)
        GLIS_ERROR_SWITCH_CASE(name, GL_INVALID_OPERATION)
        GLIS_ERROR_SWITCH_CASE(name, GL_INVALID_FRAMEBUFFER_OPERATION)
        GLIS_ERROR_SWITCH_CASE(name, GL_OUT_OF_MEMORY)

        // GENERATED BY OTHER FUNCTIONS
        GLIS_ERROR_SWITCH_CASE(name, EGL_BAD_DISPLAY)
        GLIS_ERROR_SWITCH_CASE(name, EGL_NOT_INITIALIZED)
        GLIS_ERROR_SWITCH_CASE(name, EGL_BAD_CONFIG)
        GLIS_ERROR_SWITCH_CASE(name, EGL_BAD_ATTRIBUTE)
        GLIS_ERROR_SWITCH_CASE(name, EGL_BAD_ALLOC)
        GLIS_ERROR_SWITCH_CASE(name, EGL_BAD_MATCH)

        // WHEN ALL ELSE FAILS
        GLIS_ERROR_SWITCH_CASE_DEFAULT(name, err)
    }
}

void GLIS_error_to_string() {
    GLIS_error_to_string(nullptr, glGetError());
}

void GLIS_error_to_string(const char * name) {
    GLIS_error_to_string(name, glGetError());
}

void GLIS_error_to_string(GLint err) {
    GLIS_error_to_string(nullptr, err);
}

void GLIS_GL_INFORMATION() {
    LOG_INFO("GL_VERSION: %s", glGetString(GL_VERSION));
    LOG_INFO("GL_VENDOR: %s", glGetString(GL_VENDOR));
    LOG_INFO("GL_RENDERER: %s", glGetString(GL_RENDERER));
    LOG_INFO("GL_EXTENSIONS: %s", glGetString(GL_EXTENSIONS));
}

class GLIS_CLASS {
public:
    int init_GLIS = false;
    bool
            init_eglGetDisplay = false,
            init_eglInitialize = false,
            init_eglChooseConfig = false,
            init_eglCreateWindowSurface = false,
            init_eglCreatePbufferSurface = false,
            init_eglCreateContext = false,
            init_eglMakeCurrent = false;
    const GLint *configuration_attributes = nullptr, *context_attributes = nullptr, *surface_attributes = nullptr;
    EGLint eglMajVers = 0, eglMinVers = 0, number_of_configurations = 0;
    EGLDisplay display = EGL_NO_DISPLAY;
    EGLConfig configuration = 0;
    EGLContext context = EGL_NO_CONTEXT, shared_context = EGL_NO_CONTEXT;
    EGLSurface surface = EGL_NO_SURFACE;
    ANativeWindow * native_window = nullptr;
    GLint width = 0, height = 0;
};

void GLIS_destroy_GLIS(class GLIS_CLASS & GLIS) {
    if (!GLIS.init_GLIS) return;

    if (GLIS.init_eglMakeCurrent) {
        eglMakeCurrent(GLIS.display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
        GLIS.init_eglMakeCurrent = false;
    }
    if(GLIS.init_eglCreateContext) {
        eglDestroyContext(GLIS.display, GLIS.context);
        GLIS.context = EGL_NO_CONTEXT;
        GLIS.shared_context = EGL_NO_CONTEXT;
        GLIS.init_eglCreateContext = false;
    }
    if (GLIS.init_eglCreateWindowSurface || GLIS.init_eglCreatePbufferSurface) {
        eglDestroySurface(GLIS.display, GLIS.surface);
        GLIS.surface = EGL_NO_SURFACE;
        GLIS.init_eglCreateWindowSurface = false;
        GLIS.init_eglCreatePbufferSurface = false;
    }
    if (GLIS.init_eglChooseConfig) {
        // TODO: figure how to undo init_eglChooseConfig
    }
    if (GLIS.init_eglInitialize) {
        eglTerminate(GLIS.display);
        GLIS.init_eglInitialize = false;
    }
    if (GLIS.init_eglGetDisplay) {
        GLIS.display = EGL_NO_DISPLAY;
        GLIS.init_eglGetDisplay = false;
    }
    GLIS.init_GLIS = false;
}


bool GLIS_init_display(class GLIS_CLASS & GLIS) {
    if ((GLIS.display = eglGetDisplay(EGL_DEFAULT_DISPLAY)) == EGL_NO_DISPLAY) {
        GLIS_error_to_string("eglGetDisplay");
        return false;
    }
    GLIS.init_eglGetDisplay = true;

    if (eglInitialize(GLIS.display, &GLIS.eglMajVers, &GLIS.eglMinVers) != EGL_TRUE) {
        GLIS_error_to_string("eglInitialize");
        return false;
    }
    GLIS.init_eglInitialize = true;

    LOG_INFO("EGL init with version %d.%d", GLIS.eglMajVers, GLIS.eglMinVers);
    return true;
}

bool GLIS_init_config(class GLIS_CLASS & GLIS) {
    if (!eglChooseConfig(GLIS.display, GLIS.configuration_attributes, &GLIS.configuration, 1, &GLIS.number_of_configurations)) {
        GLIS_error_to_string("eglChooseConfig");
        return false;
    }
    GLIS.init_eglChooseConfig = true;
    return true;
}

bool GLIS_init_surface_CreateWindowSurface(class GLIS_CLASS & GLIS) {
    if (!(GLIS.surface = eglCreateWindowSurface(GLIS.display, GLIS.configuration, GLIS.native_window, nullptr))) {
        GLIS_error_to_string("eglCreateWindowSurface");
        return false;
    }
    GLIS.init_eglCreateWindowSurface = true;
    return true;
}

bool GLIS_init_surface_CreatePbufferSurface(class GLIS_CLASS & GLIS) {
    if (!(GLIS.surface = eglCreatePbufferSurface(GLIS.display, GLIS.configuration, GLIS.surface_attributes))) {
        if (GLIS.surface == EGL_NO_SURFACE) LOG_INFO("EGL_NO_SURFACE");
        GLIS_error_to_string("eglCreatePbufferSurface");
        return false;
    }
    GLIS.init_eglCreatePbufferSurface = true;
    return true;
}

bool GLIS_create_context(class GLIS_CLASS & GLIS) {
    if (!(GLIS.context = eglCreateContext(GLIS.display, GLIS.configuration, GLIS.shared_context, GLIS.context_attributes))) {
        GLIS_error_to_string("eglCreateContext");
        return false;
    }
    GLIS.init_eglCreateContext = true;
    return true;
}

bool GLIS_switch_to_context(class GLIS_CLASS & GLIS) {
    if (!eglMakeCurrent(GLIS.display, GLIS.surface, GLIS.surface, GLIS.context)) {
        GLIS_error_to_string("eglMakeCurrent");
        return false;
    }
    GLIS.init_eglMakeCurrent = true;
    GLIS_GL_INFORMATION();
    return true;
}

bool GLIS_get_width_height(class GLIS_CLASS & GLIS) {
    if (!eglQuerySurface(GLIS.display, GLIS.surface, EGL_WIDTH, &GLIS.width)) {
        GLIS_error_to_string("eglQuerySurface (EGL_WIDTH)");
        return false;
    }
    if (!eglQuerySurface(GLIS.display, GLIS.surface, EGL_HEIGHT, &GLIS.height)) {
        GLIS_error_to_string("eglQuerySurface (EGL_HEIGHT)");
        return false;
    }
    return true;
}

bool GLIS_initialize(class GLIS_CLASS & GLIS, GLint surface_type) {
    if (GLIS.init_GLIS) return true;

    LOG_INFO("Initializing");

    if (!GLIS_init_display(GLIS)) {
        GLIS_destroy_GLIS(GLIS);
        return false;
    }
    if (!GLIS_init_config(GLIS)) {
        GLIS_destroy_GLIS(GLIS);
        return false;
    }
    if (surface_type == EGL_WINDOW_BIT) {
        LOG_INFO("creating window surface");
        if (!GLIS_init_surface_CreateWindowSurface(GLIS)) {
            GLIS_destroy_GLIS(GLIS);
            return false;
        }
    }
    else if (surface_type == EGL_PBUFFER_BIT) {
        LOG_INFO("creating pixel buffer surface");
        if (!GLIS_init_surface_CreatePbufferSurface(GLIS)) {
            GLIS_destroy_GLIS(GLIS);
            return false;
        }
    }
    if (!GLIS_create_context(GLIS)) {
        GLIS_destroy_GLIS(GLIS);
        return false;
    }
    if (!GLIS_switch_to_context(GLIS)) {
        GLIS_destroy_GLIS(GLIS);
        return false;
    }
    if (!GLIS_get_width_height(GLIS)) {
        GLIS_destroy_GLIS(GLIS);
        return false;
    }
    GLIS.init_GLIS = true;
    LOG_INFO("Initialized");
    return true;
}

bool GLIS_setupOnScreenRendering(class GLIS_CLASS & GLIS, EGLContext shared_context) {
    GLIS.shared_context = shared_context;

    const EGLint config[] = { EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT, EGL_NONE };
    GLIS.configuration_attributes = config;

    const EGLint context[] = { EGL_CONTEXT_CLIENT_VERSION, 3, EGL_NONE };
    GLIS.context_attributes = context;

    const EGLint surface[] = { EGL_RENDERABLE_TYPE, EGL_OPENGL_ES3_BIT, EGL_BLUE_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_RED_SIZE, 8, EGL_ALPHA_SIZE, 8, EGL_DEPTH_SIZE, 16, EGL_NONE };
    GLIS.surface_attributes = surface;

    return GLIS_initialize(GLIS, EGL_WINDOW_BIT);
}

bool GLIS_setupOnScreenRendering(class GLIS_CLASS & GLIS) {
    return GLIS_setupOnScreenRendering(GLIS, EGL_NO_CONTEXT);
}

bool GLIS_setupOffScreenRendering(class GLIS_CLASS & GLIS, int w, int h, EGLContext shared_context) {
    GLIS.shared_context = shared_context;

    const EGLint config[] = { EGL_RENDERABLE_TYPE, EGL_OPENGL_ES3_BIT, EGL_NONE };
    GLIS.configuration_attributes = config;

    const EGLint context[] = { EGL_CONTEXT_CLIENT_VERSION, 3, EGL_NONE };
    GLIS.context_attributes = context;

    const EGLint surface[] = { EGL_WIDTH, w, EGL_HEIGHT, h, EGL_NONE };
    GLIS.surface_attributes = surface;

    return GLIS_initialize(GLIS, EGL_PBUFFER_BIT);
}

bool GLIS_setupOffScreenRendering(class GLIS_CLASS & GLIS, int w, int h) {
    return GLIS_setupOffScreenRendering(GLIS, w, h, EGL_NO_CONTEXT);
}

GLboolean GLIS_ShaderCompilerSupported() {
    GLboolean GLSC_supported;
    GLIS_error_to_string_exec(glGetBooleanv(GL_SHADER_COMPILER, &GLSC_supported));
    LOG_INFO("Supports Shader Compiler: %s", GLSC_supported == GL_TRUE ? "true" : "false");
    return GLSC_supported;
}

GLuint GLIS_createShader(GLenum shaderType, const char * & src) {
    if (GLIS_ShaderCompilerSupported()) {
        const char * SHADER_TYPE = nullptr;
        switch (shaderType) {
            case GL_COMPUTE_SHADER:
                SHADER_TYPE = "Compute";
                break;
            case GL_FRAGMENT_SHADER:
                SHADER_TYPE = "Fragment";
                break;
            case GL_GEOMETRY_SHADER:
                SHADER_TYPE = "Geometry";
                break;
            case GL_VERTEX_SHADER:
                SHADER_TYPE = "Vertex";
                break;
            default:
                SHADER_TYPE = "Unknown";
                break;
        }
        LOG_INFO("Creating %s Shader", SHADER_TYPE);
        GLuint shader = GLIS_error_to_string_exec(glCreateShader(shaderType));
        if (!shader) {
            return 0;
        }
        GLIS_error_to_string_exec(glShaderSource(shader, 1, &src, nullptr));
        GLint compiled = GL_FALSE;
        LOG_INFO("Compiling %s Shader", SHADER_TYPE);
        GLIS_error_to_string_exec(glCompileShader(shader));
        GLIS_error_to_string_exec(glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled));
        if (compiled != GL_TRUE) {
            GLint infoLogLen = 0;
            GLIS_error_to_string_exec(glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLogLen));
            if (infoLogLen > 0) {
                GLchar *infoLog = (GLchar *) malloc(static_cast<size_t>(infoLogLen));
                if (infoLog) {
                    GLIS_error_to_string_exec(
                            glGetShaderInfoLog(shader, infoLogLen, nullptr, infoLog));
                    LOG_ERROR("Could not compile %s shader:\n%s\n", SHADER_TYPE, infoLog);
                    free(infoLog);
                }
            }
            GLIS_error_to_string_exec(glDeleteShader(shader));
            return 0;
        }
        assert(glIsShader(shader) == GL_TRUE);
        return shader;
    } else return 0;
}

GLboolean GLIS_validate_program_link(GLuint & Program) {
    GLint linked = GL_FALSE;
    GLIS_error_to_string_exec(glGetProgramiv(Program, GL_LINK_STATUS, &linked));
    if (linked != GL_TRUE) {
        GLint infoLogLen = 0;
        GLIS_error_to_string_exec(glGetProgramiv(Program, GL_INFO_LOG_LENGTH, &infoLogLen));
        if (infoLogLen > 0) {
            GLchar *infoLog = (GLchar *) malloc(static_cast<size_t>(infoLogLen));
            if (infoLog) {
                GLIS_error_to_string_exec(
                        glGetProgramInfoLog(Program, infoLogLen, nullptr, infoLog));
                LOG_ERROR("Could not link program:\n%s\n", infoLog);
                free(infoLog);
            }
        }
        GLIS_error_to_string_exec(glDeleteProgram(Program));
        return GL_FALSE;
    }
    return GL_TRUE;
}

GLboolean GLIS_validate_program_valid(GLuint & Program) {
    GLint validated = GL_FALSE;
    GLIS_error_to_string_exec(glValidateProgram(Program));
    GLIS_error_to_string_exec(glGetProgramiv(Program, GL_VALIDATE_STATUS, &validated));
    if (validated != GL_TRUE) {
        GLint infoLogLen = 0;
        GLIS_error_to_string_exec(glGetProgramiv(Program, GL_INFO_LOG_LENGTH, &infoLogLen));
        if (infoLogLen > 0) {
            GLchar *infoLog = (GLchar *) malloc(static_cast<size_t>(infoLogLen));
            if (infoLog) {
                GLIS_error_to_string_exec(
                        glGetProgramInfoLog(Program, infoLogLen, nullptr, infoLog));
                LOG_ERROR("Could not validate program:\n%s\n", infoLog);
                free(infoLog);
            }
        }
        GLIS_error_to_string_exec(glDeleteProgram(Program));
        return GL_FALSE;
    }
    return GL_TRUE;
}

GLboolean GLIS_validate_program(GLuint & Program) {
    if (GLIS_validate_program_link(Program) == GL_TRUE)
        if (GLIS_validate_program_valid(Program) == GL_TRUE)
            return glIsProgram(Program);
    return GL_FALSE;
}

#endif //GLNE_GLIS_H
